---
date: 2022-11-29
tags: []
seriesId: Information Hiding by Example
title: "Information Hiding by Example - Intro"
---


TODO: 
- [ ] motivations
- [ ] draft/outline examples 


probably start by creating my exhibits / examples, then write around those


So often I see people don't understand abstraction. They don't get the
concept of not knowing the details of the implementation.

Perhaps I cover this as info hiding by example?

Examples categories
- Liskov substitution is certainly a major application
  - exceptions
  - what other side-effects? mutation, persisted state (including class state)
- in data structures (sort of a flipped view of liskov sub)
- in sequence expectations? (implicitly coupled interfaces via side-effects)



Big part of data is assumptions about implementation like returning a
stripe token specifically instead of returning a genericized payment
token, or returning a file path a file isn't inherently part of the
expectation (can be similar with returning identifiers generated by
the database). Even with an interface or something that allows swapped
implementation, these structures don't allow alternate implementations

requiring implicit configuration is also a violation.Common examples
include service locator or environment configuration


Maybe I can similarly show these concepts across scopes like I did with OCP.

- UI? -> knowing about internal navigation of composed components?
- local level: mutation?
- class-ish level: exceptions, semantic values, leaky contracts
- service level: side-effects
  - configuration (including service locator), sequence expected
across interfaces


Frame info hiding with essence and accident?
How I decide scope or what to separate is driven by essence and accident. What must be know versus what could we cut and still reason about the problem. What will always be true versus what only happens to be involved.
Maybe bring in my graphic and explanation around that domain tree I made for idesign 
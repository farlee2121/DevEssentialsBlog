---
date: 2022-09-16
tags: [SOLID, Design Principles]
seriesId: "Open-Closed Principle by Example"
title: "Open-Closed Principle by Example: Series Intro"
---

The [Open-Closed Principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle), one of the [SOLID principles](https://en.wikipedia.org/wiki/SOLID), is powerful but not broadly well understood. This series will run through a bunch of examples to clarify it.
<!--more-->

<!-- TODO: the excerpt doesn't motivate why we want the OCP. It probably wont interest people who aren't interested in the OCP
maybe "is critical to flexible and stable services"
 -->

## Definitions

First off, let's make sure we're all on the same page about what the Open-Closed Principle is.

Bertrand Meyer originally defined the Open-closed Principle as
> software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification - Bertrand Meyer

Robert Martin later rephrased the principle when he coined the SOLID principles.
> You should be able to extend the behavior of a system without having to modify that system. - Bob Martin

## Motivating Questions

The Open-Closed Principle definitions are correct, but... they can be difficult to picture if you don't already know what applications look like.
We'll get into plenty of examples, but I also find it helpful to thing about the principle from the questions that motivate it.

- How can we publish libraries that can adapt to unknown users?
- How do we prevent changes from cascading between services (or other components)?
- How do we accommodate caller needs without knowing semantics from the callers?
- How can a service compose new dependencies without changing the service?

I encourage you to pause for a few minutes and write down your thoughts about these questions. You don't have to know the answers, guesses and questions are good too.
Making predictions about what you're about to learn has been [proven to improve learning](../../posts/2022-03-07-Small-Teaching-Review.md#predicting).


Bertrand Meyer originally described this principle while considering how to make reusable software libraries. 
He wanted to publish some code that could be adapted to the use cases of many consumers without the different 
consumers having access to modify the library itself. 


## Up Next
Think about all the packages you add to your software projects. Loggers, data access libraries, authentication, and much more.
These libraries would not be possible if the source code had to be changed for every system.

This same idea applies to components in our own systems. We can design our components to accommodate different needs without knowing the needs of each different caller.
This makes our system robust to change and powerful to reuse.

First we'll cover how this can be achieved [with data](../TODO.md), then [with behaviors](../TODO.md), and [with whole systems](../TODO.md). We'll also consider [examples that might look like the open-closed principle, but fail to deliver the expected value](../TODO.md).





<!-- 

post break up
- intro: definition + motivations
- OCP through data
  - parameter analogy, metadata, tags
- Chat Thread sample 
- Implicit assumption != OCP 
  - include clojure spec here
- Behaviors & OCP (Not sure on title)
  - The build up is from object inheritance, to interface, to DI
- Notification Example
- OCP + DI as architecture
- Anti-Examples
- Conclusion

Maybe merge examples into their conceptual lead ups? Depends on how long they get. At least comment the prior post is critical to understanding the example-->


<!-- Q: do I talk about approaches like loosely structured data? I.e. having a content field and letting callers decide any regular structure in that field. Like product descriptions where the structure is determined and interpreted in the UI, but saved as text to the service -->

<!-- Q: Do I add a post about custom predicates in FsSpec? It's a good example of metadata. Library doesn't care. All custom elements are in control of consumer. Can still validate, print sensible messages, *maybe* generate data (but we offer another route for adding a generation customization, registering a strategy) -->